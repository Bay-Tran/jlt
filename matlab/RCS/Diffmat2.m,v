head	1.9;
access;
symbols;
locks; strict;
comment	@// @;


1.9
date	2005.12.10.15.08.02;	author jeanluc;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.27.10.54.57;	author jeanluc;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.27.10.43.56;	author jeanluc;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.18.11.49.39;	author jeanluc;	state Exp;
branches;
next	1.5;

1.5
date	2005.08.19.15.14.32;	author jeanluc;	state Exp;
branches;
next	1.4;

1.4
date	2005.08.19.14.10.07;	author jeanluc;	state Exp;
branches;
next	1.3;

1.3
date	2005.08.19.09.56.39;	author jeanluc;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.18.13.20.11;	author jeanluc;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.06.16.40.14;	author jeanluc;	state Exp;
branches;
next	;


desc
@Second-order Fourier differentiation matrices in 2D.
@


1.9
log
@Bad bug: forgot to include the scalings when I changed things to use kron.
@
text
@function [Dx,Dy,Dxx,Dyy] = Diffmat2(N,Lx,Ly)
%DIFFMAT2   Second-order Fourier differentiation matrices in 2D.
%   [DX,DY,DXX,DYY] = DIFFMAT2(N,L) returns the sparse Fourier
%   differentiation matrices for N gridpoints on a period-L domain in
%   2D (if omitted, L defaults to 2pi).  The packing and unpacking of
%   the 2D array into a vector is compatible with PACK and UNPACK.
%
%   [DX,DY,DXX,DYY] = DIFFMAT2(N,LX,LY) specifies the period in each
%   direction.
%
%   See also FOURDIF, PACK, UNPACK.

% $Id: Diffmat2.m,v 1.8 2005/11/27 10:54:57 jeanluc Exp $

if nargin < 2
  Lx = 2*pi;
end

if nargin < 3
  Ly = Lx;
end

k1x = 2*pi/Lx;
k1y = 2*pi/Ly;

% Derivatives of phi using Fourier differentiation matrices
[x0,D]  = fourdif(N,1);
[x0,D2] = fourdif(N,2);

D = sparse(D);
D2 = sparse(D2);

% Dx is an antisymmetric toeplitz matrix.
Dx = kron(k1x*D,speye(N));

% Dy just consists of the differentiation matrix D repeated along
% the diagonal.
Dy = kron(speye(N),k1y*D);

% Dxx is a symmetric toeplitz matrix.
Dxx = kron(k1x^2*D2,speye(N));

% Dyy just consists of the differentiation matrix D2 repeated along
% the diagonal.
Dyy = kron(speye(N),k1y^2*D2);

% Ditch Dxy: too full.
%Dxy = kron(D,D);
@


1.8
log
@Changed the wording of the help mesg, since pack and unpack no longer
used in this routine.
@
text
@d13 1
a13 1
% $Id: Diffmat2.m,v 1.7 2005/11/27 10:43:56 jeanluc Exp $
d34 1
a34 1
Dx = kron(D,speye(N));
d38 1
a38 1
Dy = kron(speye(N),D);
d41 1
a41 1
Dxx = kron(D2,speye(N));
d45 1
a45 1
Dyy = kron(speye(N),D2);
@


1.7
log
@Simplify greatly using kron.
@
text
@d6 1
a6 1
%   the 2D array into a vector is effected by PACK and UNPACK.
d13 1
a13 1
% $Id: Diffmat2.m,v 1.6 2005/09/18 11:49:39 jeanluc Exp $
@


1.6
log
@Optional specification of x and y period.
@
text
@d13 1
a13 1
% $Id: Diffmat2.m,v 1.5 2005/08/19 15:14:32 jeanluc Exp $
d30 3
d34 1
a34 2
Dx = spdiags(repmat(k1x*D(1,:),[N^2 1]),[0:N:N^2-1],N^2,N^2);
Dx = Dx - Dx.';
d38 1
a38 3
Dydiag = cell(N,1);
[Dydiag{:}] = deal(k1y*sparse(D));
Dy = blkdiag(Dydiag{:});
d41 1
a41 2
Dxx = spdiags(repmat(k1x^2*[D2(1,end:-1:2) D2(1,:)],[N^2 1]),...
	      [-N*(N-1):N:N*(N-1)],N^2,N^2);
d45 2
a46 7
Dyydiag = cell(N,1);
[Dyydiag{:}] = deal(k1y^2*sparse(D2));
Dyy = blkdiag(Dyydiag{:});

% No better way to compute Dxy than to use the sparse
% representation of Dx and Dy, I think.  Dxy is dense.
%
d48 1
a48 1
%Dxy = Dx*Dy;
@


1.5
log
@Speed up a bit (factor of 2ish) by getting rid of the loops for Dy and Dyy.
@
text
@d1 1
a1 1
function [Dx,Dy,Dxx,Dyy] = Diffmat2(N,L)
d4 6
a9 3
%   differentiation matrices for gridpoints on a period-L domain in 2D
%   (if omitted, L defaults to 2pi).  The packing and unpacking of the
%   2D array into a vector is effected by PACK and UNPACK.
d13 1
a13 1
% $Id: Diffmat2.m,v 1.4 2005/08/19 14:10:07 jeanluc Exp $
d16 5
a20 1
  L = 2*pi;
d22 3
a24 1
k1 = 2*pi/L;
a28 2
D = k1*D;
D2 = k1^2*D2;
d31 1
a31 1
Dx = spdiags(repmat(D(1,:),[N^2 1]),[0:N:N^2-1],N^2,N^2);
d37 1
a37 1
[Dydiag{:}] = deal(sparse(D));
d41 1
a41 1
Dxx = spdiags(repmat([D2(1,end:-1:2) D2(1,:)],[N^2 1]),...
d47 1
a47 1
[Dyydiag{:}] = deal(sparse(D2));
@


1.4
log
@Don't compute Dxy, since it is basically a full matrix.
@
text
@d10 1
a10 1
% $Id: Diffmat2.m,v 1.3 2005/08/19 09:56:39 jeanluc Exp $
d29 3
a31 4
Dy = spalloc(N^2,N^2,N^3);
for ii = 0:N-1
  Dy(ii*N + [1:N],ii*N + [1:N]) = D;
end
d35 1
a35 1
	       [-N*(N-1):N:N*(N-1)],N^2,N^2);
d39 3
a41 4
Dyy = spalloc(N^2,N^2,N^3);
for ii = 0:N-1
  Dyy(ii*N + [1:N],ii*N + [1:N]) = D2;
end
@


1.3
log
@Define k1.
@
text
@d1 1
a1 1
function [Dx,Dy,Dxx,Dyy,Dxy] = Diffmat2(N,L)
d3 1
a3 1
%   [DX,DY,DXX,DYY,DXY] = DIFFMAT2(N,L) returns the sparse Fourier
d10 1
a10 1
% $Id: Diffmat2.m,v 1.2 2005/08/18 13:20:11 jeanluc Exp $
d47 3
a49 1
Dxy = Dx*Dy;
@


1.2
log
@Added help message.
@
text
@d10 1
a10 1
% $Id: Diffmat2.m,v 1.1 2005/08/06 16:40:14 jeanluc Exp $
d15 1
d20 2
a21 2
D = (2*pi/L)*D;
D2 = (2*pi/L)^2*D2;
@


1.1
log
@Initial revision
@
text
@d3 6
d10 1
a10 1
% $Id$
@
